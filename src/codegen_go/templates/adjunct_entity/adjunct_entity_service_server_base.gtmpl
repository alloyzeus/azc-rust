package {{.pkg_name}}server

import (
	"crypto/rand"
	"encoding/binary"

	{{.base.azerrs_pkg}} "{{.base.azerrs_import}}"
	"github.com/jmoiron/sqlx"

	"{{.pkg_path}}"
)

const (
	{{unexported_field .type_name}}DBTableName           = "{{.type_name_snake}}_dt"
	{{unexported_field .type_name}}DBTablePrimaryKeyName = {{unexported_field .type_name}}DBTableName + "_pkey"
)

// {{.service_name}}Serverbase is the server-side
// base implementation of {{.service_name}}.
type {{.service_name}}ServerBase struct {
	db *sqlx.DB
}

const (
	{{unexported_field .type_name}}DBColMDCreationTimestamp  = "md_c_ts"
	{{unexported_field .type_name}}DBColMDCreationTerminalID = "md_c_tid"
	{{unexported_field .type_name}}DBColMDCreationUserID     = "md_c_uid"
	{{- if .lifecycle.deletion.enabled}}
	{{unexported_field .type_name}}DBColMDDeletionTimestamp  = "md_d_ts"
	{{unexported_field .type_name}}DBColMDDeletionTerminalID = "md_d_tid"
	{{unexported_field .type_name}}DBColMDDeletionUserID     = "md_d_uid"
	{{- if .lifecycle.deletion.notes.enabled}}
	{{unexported_field .type_name}}DBColMDDeletionNotes      = "md_d_notes"
	{{- end}}
	{{- end}}
	{{unexported_field .type_name}}DBColIDNum                  = "id_num"

	{{if not .global_scope -}}{{range .hosts -}}
	{{unexported_field $.type_name}}DBCol{{.}}ID = "{{adjunct_host_id_db_col_name .}}"
	{{end}}{{- end}}
)

{{- /* TODO: generate the following generator function only when the id num is random */}}

// Generate{{.id_num_type_name}} generates a new {{.pkg_name}}.{{.id_num_type_name}}.
// Note that this function does not consult any database nor registry.
// This method will not create an instance of {{.pkg_name}}.{{.type_name}}, i.e., the
// resulting {{.pkg_name}}.{{.id_num_type_name}} might or might not refer to valid instance
// of {{.pkg_name}}.{{.type_name}}. The resulting {{.pkg_name}}.{{.id_num_type_name}} is designed to be
// used as an argument to create a new instance of {{.pkg_name}}.{{.type_name}}.
//
// The embeddedFieldBits argument could be constructed by combining
// {{.pkg_name}}.{{.id_num_type_name}}*Bits constants. If none are defined,
// use the value of 0.
func Generate{{.id_num_type_name}}(
	embeddedFieldBits u{{.id_num_def.type_name}},
) ({{.pkg_name}}.{{.id_num_type_name}}, error) {
	idBytes := make([]byte, {{.id_num_def.primitive_size_bytes}})
	_, err := rand.Read(idBytes)
	if err != nil {
		return {{.pkg_name}}.{{.id_num_type_name}}Zero, {{.base.azerrs_pkg}}.Wrap("random number source reading", err)
	}

	idUint := (embeddedFieldBits & {{.pkg_name}}.{{.id_num_type_name}}EmbeddedFieldsMask) |
		(binary.BigEndian.U{{.id_num_def.type_name}}(idBytes) & {{.pkg_name}}.{{.id_num_type_name}}IdentifierBitsMask)
	return {{.pkg_name}}.{{.id_num_type_name}}(idUint), nil
}
