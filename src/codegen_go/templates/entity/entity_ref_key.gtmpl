// {{.ref_key_type_name}} is used to identify
// an instance of entity {{.type_name}} system-wide.
type {{.ref_key_type_name}} {{.id_num_type_name}}

// New{{.ref_key_type_name}} returns a new instance
// of {{.ref_key_type_name}} with the provided attribute values.
func New{{.ref_key_type_name}}(
	idNum {{.id_num_type_name}},
) {{.ref_key_type_name}} {
	return {{.ref_key_type_name}}(idNum)
}

// To ensure that it conforms the interfaces. If any of these is failing,
// there's a bug in the generator.
var _ {{.base.azid_pkg}}.RefKey = {{unexported_global .ref_key_type_name}}Zero
var _ {{.base.azid_pkg}}.BinUnmarshalable = &{{unexported_global .ref_key_type_name}}ZeroVar
var _ {{.base.azid_pkg}}.BinFieldUnmarshalable = &{{unexported_global .ref_key_type_name}}ZeroVar
var _ {{.base.azid_pkg}}.TextUnmarshalable = &{{unexported_global .ref_key_type_name}}ZeroVar
var _ {{.base.azcore_pkg}}.EntityRefKey = {{unexported_global .ref_key_type_name}}Zero
{{- range .implements}}{{- if .is_system}}
var _ {{$.base.azcore_pkg}}.{{.type_name}}RefKey = {{unexported_global $.ref_key_type_name}}Zero
{{- end}}{{- end}}

const {{unexported_global .ref_key_type_name}}Zero =
	{{.ref_key_type_name}}({{.id_num_type_name}}Zero)
var {{unexported_global .ref_key_type_name}}ZeroVar =
	{{unexported_global .ref_key_type_name}}Zero

// {{.ref_key_type_name}}Zero returns
// a zero-valued instance of {{.ref_key_type_name}}.
func {{.ref_key_type_name}}Zero() {{.ref_key_type_name}} {
	return {{unexported_global .ref_key_type_name}}Zero
}

// AZRefKey is required for conformance with {{.base.azid_pkg}}.RefKey.
func ({{.ref_key_type_name}}) AZRefKey() {}

// AZEntityRefKey is required for conformance
// with {{.base.azcore_pkg}}.EntityRefKey.
func ({{.ref_key_type_name}}) AZEntityRefKey() {}

// IDNum returns the scoped identifier of the entity.
func (refKey {{.ref_key_type_name}}) IDNum() {{.id_num_type_name}} {
	return {{.id_num_type_name}}(refKey)
}

// IDNumPtr returns a pointer to a copy of the id-num if it's considered valid
// otherwise it returns nil.
func (refKey {{.ref_key_type_name}}) IDNumPtr() *{{.id_num_type_name}} {
	if refKey.IsNotStaticallyValid() {
		return nil
	}
	i := refKey.IDNum()
	return &i
}

// AZIDNum is required for conformance with {{.base.azid_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) AZIDNum() {{.base.azid_pkg}}.IDNum {
	return {{.id_num_type_name}}(refKey)
}

{{- range .implements}}{{- if .is_system}}

// {{.type_name}}IDNum is required for conformance
// with {{$.base.azcore_pkg}}.{{.type_name}}RefKey.
func (refKey {{$.ref_key_type_name}}) {{.type_name}}IDNum() {{$.base.azcore_pkg}}.{{.type_name}}IDNum {
	return {{$.id_num_type_name}}(refKey)
}

{{- end}}{{- end}}

// IsZero is required as {{.ref_key_type_name}} is a value-object.
func (refKey {{.ref_key_type_name}}) IsZero() bool {
	return {{.id_num_type_name}}(refKey) == {{.id_num_type_name}}Zero
}

// IsStaticallyValid returns true if this instance is valid as an isolated value
// of {{.ref_key_type_name}}.
// It doesn't tell whether it refers to a valid instance of {{.type_name}}.
func (refKey {{.ref_key_type_name}}) IsStaticallyValid() bool {
	return {{.id_num_type_name}}(refKey).IsStaticallyValid()
}

// IsNotStaticallyValid returns the negation of value returned by IsStaticallyValid.
func (refKey {{.ref_key_type_name}}) IsNotStaticallyValid() bool {
	return !refKey.IsStaticallyValid()
}

// Equals is required for conformance with {{.base.azcore_pkg}}.EntityRefKey.
func (refKey {{.ref_key_type_name}}) Equals(other interface{}) bool {
	if x, ok := other.({{.ref_key_type_name}}); ok {
		return x == refKey
	}
	if x, _ := other.(*{{.ref_key_type_name}}); x != nil {
		return *x == refKey
	}
	return false
}

// Equal is required for conformance with {{.base.azcore_pkg}}.EntityRefKey.
func (refKey {{.ref_key_type_name}}) Equal(other interface{}) bool {
	return refKey.Equals(other)
}

// Equals{{.ref_key_type_name}} returs true
// if the other value has the same attributes as refKey.
func (refKey {{.ref_key_type_name}}) Equals{{.ref_key_type_name}}(
	other {{.ref_key_type_name}},
) bool {
	return other == refKey
}

func (refKey {{.ref_key_type_name}}) AZIDBin() []byte {
	b := make([]byte, {{.id_num_def.primitive_size_bytes}} + 1)
	b[0] = {{.base.azid_pkg}}.BinDataTypeInt{{.id_num_def.primitive_size}}.Byte()
	binary.BigEndian.PutUint{{.id_num_def.primitive_size}}(b[1:], uint{{.id_num_def.primitive_size}}(refKey))
	return b
}

func {{.ref_key_type_name}}FromAZIDBin(b []byte) (refKey {{.ref_key_type_name}}, readLen int, err error) {
	typ, err := {{.base.azid_pkg}}.BinDataTypeFromByte(b[0])
	if err != nil {
		return {{unexported_global .ref_key_type_name}}Zero, 0,
			errors.ArgWrap("", "type parsing", err)
	}
	if typ != {{.base.azid_pkg}}.BinDataTypeInt{{.id_num_def.primitive_size}} {
		return {{unexported_global .ref_key_type_name}}Zero, 0,
			errors.Arg("", errors.EntMsg("type", "unsupported"))
	}

	i, readLen, err := {{.ref_key_type_name}}FromAZIDBinField(b[1:], typ)
	if err != nil {
		return {{unexported_global .ref_key_type_name}}Zero, 0,
			errors.ArgWrap("", "id-num data parsing", err)
	}

	return {{.ref_key_type_name}}(i), 1 + readLen, nil
}

// UnmarshalAZIDBin is required for conformance
// with {{.base.azcore_pkg}}.BinFieldUnmarshalable.
func (refKey *{{.ref_key_type_name}}) UnmarshalAZIDBin(b []byte) (readLen int, err error) {
	i, readLen, err := {{.ref_key_type_name}}FromAZIDBin(b)
	if err == nil {
		*refKey = i
	}
	return readLen, err
}

func (refKey {{.ref_key_type_name}}) AZIDBinField() ([]byte, {{.base.azid_pkg}}.BinDataType) {
	return {{.id_num_type_name}}(refKey).AZIDBinField()
}

func {{.ref_key_type_name}}FromAZIDBinField(
	b []byte, typeHint {{.base.azid_pkg}}.BinDataType,
) (refKey {{.ref_key_type_name}}, readLen int, err error) {
	idNum, n, err := {{.id_num_type_name}}FromAZIDBinField(b, typeHint)
	if err != nil {
		return {{unexported_global .ref_key_type_name}}Zero, n, err
	}
	return {{.ref_key_type_name}}(idNum), n, nil
}

// UnmarshalAZIDBinField is required for conformance
// with {{.base.azcore_pkg}}.BinFieldUnmarshalable.
func (refKey *{{.ref_key_type_name}}) UnmarshalAZIDBinField(
	b []byte, typeHint {{.base.azid_pkg}}.BinDataType,
) (readLen int, err error) {
	i, readLen, err := {{.ref_key_type_name}}FromAZIDBinField(b, typeHint)
	if err == nil {
		*refKey = i
	}
	return readLen, err
}

const {{unexported_global .ref_key_type_name}}AZIDTextPrefix = "{{.ref_key_def.azid_text.prefix}}"

// AZIDText is required for conformance
// with {{.base.azid_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) AZIDText() string {
	if !refKey.IsStaticallyValid() {
		return ""
	}

	return {{unexported_global .ref_key_type_name}}AZIDTextPrefix +
		{{.base.azid_pkg}}.TextEncode(refKey.AZIDBin())
}

// {{.ref_key_type_name}}FromAZIDText creates a new instance of
// {{.ref_key_type_name}} from its azid-text form.
func {{.ref_key_type_name}}FromAZIDText(s string) ({{.ref_key_type_name}}, error) {
	if s == "" {
		return {{.ref_key_type_name}}Zero(), nil
	}
	if !strings.HasPrefix(s, {{unexported_global .ref_key_type_name}}AZIDTextPrefix) {
		return {{.ref_key_type_name}}Zero(),
			errors.Arg("", errors.EntMsg("prefix", "mismatch"))
	}
	s = strings.TrimPrefix(s, {{unexported_global .ref_key_type_name}}AZIDTextPrefix)
	b, err := {{.base.azid_pkg}}.TextDecode(s)
	if err != nil {
		return {{.ref_key_type_name}}Zero(),
			errors.ArgWrap("", "data parsing", err)
	}
	refKey, _, err := {{.ref_key_type_name}}FromAZIDBin(b)
	if err != nil {
		return {{.ref_key_type_name}}Zero(),
			errors.ArgWrap("", "data decoding", err)
	}
	return refKey, nil
}

// UnmarshalAZIDText is required for conformance
// with {{.base.azid_pkg}}.TextUnmarshalable.
func (refKey *{{.ref_key_type_name}}) UnmarshalAZIDText(s string) error {
	r, err := {{.ref_key_type_name}}FromAZIDText(s)
	if err == nil {
		*refKey = r
	}
	return err
}

// MarshalText is for compatibility with Go's encoding.TextMarshaler
func (refKey {{.ref_key_type_name}}) MarshalText() ([]byte, error) {
	return []byte(refKey.AZIDText()), nil
}

// UnmarshalText is for conformance with Go's encoding.TextUnmarshaler
func (refKey *{{.ref_key_type_name}}) UnmarshalText(b []byte) error {
	r, err := {{.ref_key_type_name}}FromAZIDText(string(b))
	if err == nil {
		*refKey = r
	}
	return err
}

// MarshalJSON makes this type JSON-marshalable.
func (refKey {{.ref_key_type_name}}) MarshalJSON() ([]byte, error) {
	// We assume that there are no symbols in azid-text
	return []byte("\"" + refKey.AZIDText() + "\""), nil
}

// UnmarshalJSON parses a JSON value.
func (refKey *{{.ref_key_type_name}}) UnmarshalJSON(b []byte) error {
	s := strings.Trim(string(b), "\"")
	if s == "" {
		*refKey = {{.ref_key_type_name}}Zero()
		return nil
	}
	i, err := {{.ref_key_type_name}}FromAZIDText(s)
	if err == nil {
		*refKey = i
	}
	return err
}

// {{.ref_key_type_name}}Service abstracts
// {{.ref_key_type_name}}-related services.
type {{.ref_key_type_name}}Service interface {
	// Is{{.ref_key_type_name}} is to check if the ref-key is
	// trully registered to system. It does not check whether the instance
	// is active or not.
	Is{{.ref_key_type_name}}Registered(refKey {{.ref_key_type_name}}) bool
}

// {{.ref_key_type_name}}Error defines an interface for all
// {{.ref_key_type_name}}-related errors.
type {{.ref_key_type_name}}Error interface {
	error
	{{.ref_key_type_name}}Error()
}
