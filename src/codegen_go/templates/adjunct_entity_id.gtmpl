// {{.id_type_name}} is a scoped identifier
// used to identify an instance of adjunct entity {{.type_name}}
// scoped within its host entity(s).
type {{.id_type_name}} {{.id_def.type_name}}

// To ensure that it conforms the interfaces. If any of these is failing,
// there's a bug in the generator.
var _ {{.base.azcore_pkg}}.EID = {{.id_type_name}}Zero
var _ {{.base.azcore_pkg}}.AdjunctEntityID = {{.id_type_name}}Zero
var _ {{.base.azer_pkg}}.BinFieldUnmarshalable = &{{unexported_global .id_type_name}}ZeroVar
{{- if .implements}}
var _ {{.base.azcore_pkg}}.{{.implements}}ID = {{.id_type_name}}Zero
{{- end}}

// {{.id_type_name}}SignificantBitsMask is used to
// extract significant bits from an instance of {{.id_type_name}}.
const {{.id_type_name}}SignificantBitsMask uint{{.id_def.primitive_size}} =
	{{.id_def.significant_bits_mask}}

// {{.id_type_name}}Zero is the zero value for {{.id_type_name}}.
const {{.id_type_name}}Zero =
	{{.id_type_name}}(0)

// {{unexported_global .id_type_name}}ZeroVar is used for testing
// pointer-based interfaces conformance.
var {{unexported_global .id_type_name}}ZeroVar =
	{{.id_type_name}}Zero

// {{.id_type_name}}FromPrimitiveValue creates an instance
// of {{.id_type_name}} from its primitive value.
func {{.id_type_name}}FromPrimitiveValue(v {{.id_def.type_name}}) {{.id_type_name}} {
	return {{.id_type_name}}(v)
}

// {{.id_type_name}}FromAZERBinField creates {{.id_type_name}} from
// its azer-bin form.
func {{.id_type_name}}FromAZERBinField(
	b []byte, typeHint {{.base.azer_pkg}}.BinDataType,
) (id {{.id_type_name}}, readLen int, err error) {
	if typeHint != {{.base.azer_pkg}}.BinDataTypeUnspecified && typeHint != {{.base.azer_pkg}}.BinDataTypeInt{{.id_def.primitive_size}} {
		return {{.id_type_name}}(0), 0,
			errors.ArgMsg("typeHint", "unsupported")
	}
	i := binary.BigEndian.Uint{{.id_def.primitive_size}}(b)
	return {{.id_type_name}}(i), {{.id_def.primitive_size_bytes}}, nil
}

// PrimitiveValue returns the ID in its primitive type. Prefer to use
// this method instead of casting directly.
func (id {{.id_type_name}}) PrimitiveValue() {{.id_def.type_name}} {
	return {{.id_def.type_name}}(id)
}

// AZEID is required
// for conformance with {{.base.azcore_pkg}}.EID.
func ({{.id_type_name}}) AZEID() {}

// AZAdjunctEntityID is required
// for conformance with {{.base.azcore_pkg}}.AdjunctEntityID.
func ({{.id_type_name}}) AZAdjunctEntityID() {}

{{- if .implements}}

// AZ{{.implements}}ID is required for conformance
// with {{.base.azcore_pkg}}.{{.implements}}ID.
func ({{.id_type_name}}) AZ{{.implements}}ID() {}

{{- end}}

// IsZero is required as {{.id_type_name}} is a value-object.
func (id {{.id_type_name}}) IsZero() bool {
	return id == {{.id_type_name}}Zero
}

// IsValid returns true if this instance is valid independently as an ID.
// It doesn't tell whether it refers to a valid instance of {{.type_name}}.
func (id {{.id_type_name}}) IsValid() bool {
	return int{{.id_def.primitive_size}}(id) > 0 &&
		(uint{{.id_def.primitive_size}}(id) & {{.id_type_name}}SignificantBitsMask) != 0
}

// IsNotValid returns the negation of value returned by IsValid().
func (id {{.id_type_name}}) IsNotValid() bool {
	return !id.IsValid()
}

// AZERBinField is required for conformance
// with {{.base.azcore_pkg}}.EID.
func (id {{.id_type_name}}) AZERBinField() ([]byte, {{.base.azer_pkg}}.BinDataType) {
	b := make([]byte, {{.id_def.primitive_size_bytes}})
	binary.BigEndian.PutUint{{.id_def.primitive_size}}(b, uint{{.id_def.primitive_size}}(id))
	return b, {{.base.azer_pkg}}.BinDataTypeInt{{.id_def.primitive_size}}
}

// UnmarshalAZERBinField is required for conformance
// with {{.base.azer_pkg}}.BinFieldUnmarshalable.
func (id *{{.id_type_name}}) UnmarshalAZERBinField(
	b []byte, typeHint {{.base.azer_pkg}}.BinDataType,
) (readLen int, err error) {
	i, readLen, err := {{.id_type_name}}FromAZERBinField(b, typeHint)
	if err == nil {
		*id = i
	}
	return readLen, err
}

// Equals is required as {{.id_type_name}} is a value-object.
//
// Use Equals{{.id_type_name}} method if the other value
// has the same type.
func (id {{.id_type_name}}) Equals(other interface{}) bool {
	if x, ok := other.({{.id_type_name}}); ok {
		return x == id
	}
	if x, _ := other.(*{{.id_type_name}}); x != nil {
		return *x == id
	}
	return false
}

// Equal is a wrapper for Equals method. It is required for
// compatibility with github.com/google/go-cmp
func (id {{.id_type_name}}) Equal(other interface{}) bool {
	return id.Equals(other)
}

// Equals{{.id_type_name}} determines if the other instance
// is equal to this instance.
func (id {{.id_type_name}}) Equals{{.id_type_name}}(
	other {{.id_type_name}},
) bool {
	return id == other
}
