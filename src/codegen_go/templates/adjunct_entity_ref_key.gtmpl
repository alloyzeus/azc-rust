// {{.ref_key_type_name}} is used to identify
// an instance of adjunct entity {{.type_name}} system-wide.
type {{.ref_key_type_name}} struct {
	{{if not .global_scope -}}{{range .hosts -}}
	{{.}} {{.}}RefKey
	{{end}}{{- end -}}
	id {{.id_type_name}}
}

// To ensure that it conforms the interfaces
var _ {{.base.azcore_pkg}}.RefKey = _{{.ref_key_type_name}}Zero
var _ {{.base.azcore_pkg}}.AdjunctEntityRefKey = _{{.ref_key_type_name}}Zero
{{if .implements -}}
var _ {{.base.azcore_pkg}}.{{.implements}}RefKey = _{{.ref_key_type_name}}Zero
{{- end}}

var _{{.ref_key_type_name}}Zero = {{.ref_key_type_name}}{
	{{if not .global_scope -}}{{range .hosts -}}
	{{.}}: {{.}}RefKeyZero(),
	{{end}}{{- end -}}
	id: {{.id_type_name}}Zero,
}

// {{.ref_key_type_name}}Zero returns
// a zero-valued instance of {{.ref_key_type_name}}.
func {{.ref_key_type_name}}Zero() {{.ref_key_type_name}} {
	return _{{.ref_key_type_name}}Zero
}

// AZRefKey is required by {{.base.azcore_pkg}}.RefKey interface.
func ({{.ref_key_type_name}}) AZRefKey() {}

// AZAdjunctEntityRefKey is required
// by {{.base.azcore_pkg}}.AdjunctEntityRefKey interface.
func ({{.ref_key_type_name}}) AZAdjunctEntityRefKey() {}

// ID is required for conformance with {{.base.azcore_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) ID() {{.base.azcore_pkg}}.EID {
	return refKey.id
}

{{if .implements -}}
// {{.implements}}ID is required for conformance with {{.base.azcore_pkg}}.{{.implements}}RefKey.
func (refKey {{.ref_key_type_name}}) {{.implements}}ID() {{.base.azcore_pkg}}.{{.implements}}ID {
	return refKey.id
}

{{end -}}

// IsZero is required as {{.ref_key_type_name}} is a value-object.
func (refKey {{.ref_key_type_name}}) IsZero() bool {
	return {{if not .global_scope -}}{{range .hosts}}refKey.{{.}}.IsZero() &&
		{{end}}{{- end -}} refKey.id == {{.id_type_name}}Zero
}

// Equals is required for conformance with {{.base.azcore_pkg}}.AdjunctEntityRefKey.
func (refKey {{.ref_key_type_name}}) Equals(other interface{}) bool {
	if x, ok := other.({{.ref_key_type_name}}); ok {
		return {{if not .global_scope -}}{{range .hosts}}refKey.{{.}}.Equals{{.}}RefKey(x.{{.}}) &&
			{{end}}{{- end -}} refKey.id == x.id
	}
	if x, _ := other.(*{{.ref_key_type_name}}); x != nil {
		return {{if not .global_scope -}}{{range .hosts}}refKey.{{.}}.Equals{{.}}RefKey(x.{{.}}) &&
			{{end}}{{- end -}} refKey.id == x.id
	}
	return false
}

// Equal is required for conformance with {{.base.azcore_pkg}}.AdjunctEntityRefKey.
func (refKey {{.ref_key_type_name}}) Equal(other interface{}) bool {
	return refKey.Equals(other)
}

// Equals{{.ref_key_type_name}} returs true
// if the other value has the same attributes as refKey.
func (refKey {{.ref_key_type_name}}) Equals{{.ref_key_type_name}}(
	other {{.ref_key_type_name}},
) bool {
	return {{if not .global_scope -}}{{range .hosts}}refKey.{{.}}.Equals{{.}}RefKey(other.{{.}}) &&
		{{end}}{{- end -}} refKey.id == other.id
}

// RefKeyString returns an encoded representation of this instance.
//
// RefKeyString is required by {{.base.azcore_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) RefKeyString() string {
	// TODO: refkeystring should be prepared as it needs to be strictly
	// consistent across implementations.
	// something like /host1_type-host1_id/host2_type-host2_id/hostn_type-hostn_id/own_type-own_id
	// or for global adjuncts /own_type-own_id
	//
	// note that a ref key might comprise of other ref keys. so, we will have
	// something like A(B(C(), D()), E()). the default pattern must be able
	// to accomodate such structure.
	return "TODO"
}
