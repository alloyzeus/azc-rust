// {{.ref_key_type_name}} is used to identify
// an instance of adjunct entity {{.type_name}} system-wide.
type {{.ref_key_type_name}} struct {
	{{if not .global_scope -}}{{range .hosts -}}
	{{unexported_field .}} {{.}}RefKey
	{{end}}{{- end -}}
	idNum {{.id_num_type_name}}
}

// The total number of fields in the struct.
const {{unexported_global .ref_key_type_name}}FieldCount = {{len .hosts}} + 1

// New{{.ref_key_type_name}} returns a new instance
// of {{.ref_key_type_name}} with the provided attribute values.
func New{{.ref_key_type_name}}(
	{{if not .global_scope -}}{{range .hosts -}}
	{{arg_name .}} {{.}}RefKey,
	{{end}}{{- end -}}
	idNum {{.id_num_type_name}},
) {{.ref_key_type_name}} {
	return {{.ref_key_type_name}}{
		{{if not .global_scope -}}{{- range .hosts -}}
		{{unexported_field .}}: {{arg_name .}},
		{{end}}{{end -}}
		idNum: idNum,
	}
}

// To ensure that it conforms the interfaces. If any of these is failing,
// there's a bug in the generator.
var _ {{.base.azcore_pkg}}.RefKey = {{unexported_global .ref_key_type_name}}Zero
var _ {{.base.azcore_pkg}}.AdjunctEntityRefKey = {{unexported_global .ref_key_type_name}}Zero
{{- if .implements}}
var _ {{.base.azcore_pkg}}.{{.implements}}RefKey = {{unexported_global .ref_key_type_name}}Zero
{{- end}}

var {{unexported_global .ref_key_type_name}}Zero = {{.ref_key_type_name}}{
	{{if not .global_scope -}}{{range .hosts -}}
	{{unexported_field .}}: {{.}}RefKeyZero(),
	{{end}}{{- end -}}
	idNum: {{.id_num_type_name}}Zero,
}

// {{.ref_key_type_name}}Zero returns
// a zero-valued instance of {{.ref_key_type_name}}.
func {{.ref_key_type_name}}Zero() {{.ref_key_type_name}} {
	return {{unexported_global .ref_key_type_name}}Zero
}

// AZRefKey is required by {{.base.azcore_pkg}}.RefKey interface.
func ({{.ref_key_type_name}}) AZRefKey() {}

// AZAdjunctEntityRefKey is required
// by {{.base.azcore_pkg}}.AdjunctEntityRefKey interface.
func ({{.ref_key_type_name}}) AZAdjunctEntityRefKey() {}

// IDNum returns the scoped identifier of the entity.
func (refKey {{.ref_key_type_name}}) IDNum() {{.id_num_type_name}} {
	return refKey.idNum
}

// IDNumPtr returns a pointer to a copy of the IDNum if it's considered valid
// otherwise it returns nil.
func (refKey {{.ref_key_type_name}}) IDNumPtr() *{{.id_num_type_name}} {
	if refKey.IsNotValid() {
		return nil
	}
	i := refKey.IDNum()
	return &i
}

// EID is required for conformance with {{.base.azcore_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) EID() {{.base.azcore_pkg}}.EID {
	return refKey.idNum
}

{{- if .implements}}

// {{.implements}}IDNum is required for conformance
// with {{.base.azcore_pkg}}.{{.implements}}RefKey.
func (refKey {{.ref_key_type_name}}) {{.implements}}IDNum() {{.base.azcore_pkg}}.{{.implements}}IDNum {
	return refKey.idNum
}

{{- end}}

// IsZero is required as {{.ref_key_type_name}} is a value-object.
func (refKey {{.ref_key_type_name}}) IsZero() bool {
	return {{if not .global_scope -}}{{range .hosts}}refKey.{{unexported_field .}}.IsZero() &&
		{{end}}{{- end -}} refKey.idNum == {{.id_num_type_name}}Zero
}

// IsValid returns true if this instance is valid independently as a ref-key.
// It doesn't tell whether it refers to a valid instance of {{.type_name}}.
func (refKey {{.ref_key_type_name}}) IsValid() bool {
	return {{if not .global_scope -}}{{range .hosts}}refKey.{{unexported_field .}}.IsValid() &&
		{{end}}{{- end -}} refKey.idNum.IsValid()
}

// IsNotValid returns the negation of value returned by IsValid().
func (refKey {{.ref_key_type_name}}) IsNotValid() bool {
	return !refKey.IsValid()
}

// Equals is required for conformance with {{.base.azcore_pkg}}.AdjunctEntityRefKey.
func (refKey {{.ref_key_type_name}}) Equals(other interface{}) bool {
	if x, ok := other.({{.ref_key_type_name}}); ok {
		return {{if not .global_scope -}}{{range .hosts}}refKey.{{unexported_field .}}.Equals{{.}}RefKey(x.{{unexported_field .}}) &&
			{{end}}{{- end -}} refKey.idNum == x.idNum
	}
	if x, _ := other.(*{{.ref_key_type_name}}); x != nil {
		return {{if not .global_scope -}}{{range .hosts}}refKey.{{unexported_field .}}.Equals{{.}}RefKey(x.{{unexported_field .}}) &&
			{{end}}{{- end -}} refKey.idNum == x.idNum
	}
	return false
}

// Equal is required for conformance with {{.base.azcore_pkg}}.AdjunctEntityRefKey.
func (refKey {{.ref_key_type_name}}) Equal(other interface{}) bool {
	return refKey.Equals(other)
}

// Equals{{.ref_key_type_name}} returns true
// if the other value has the same attributes as refKey.
func (refKey {{.ref_key_type_name}}) Equals{{.ref_key_type_name}}(
	other {{.ref_key_type_name}},
) bool {
	return {{if not .global_scope -}}{{range .hosts}}refKey.{{unexported_field .}}.Equals{{.}}RefKey(other.{{unexported_field .}}) &&
		{{end}}{{- end -}} refKey.idNum == other.idNum
}

// AZERBin is required for conformance
// with {{.base.azcore_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) AZERBin() []byte {
	data, typ := refKey.AZERBinField()
	out := []byte{typ.Byte()}
	return append(out, data...)
}

// {{.ref_key_type_name}}FromAZERBin creates a new instance of
// {{.ref_key_type_name}} from its azer-bin form.
func {{.ref_key_type_name}}FromAZERBin(
	b []byte,
) (refKey {{.ref_key_type_name}}, readLen int, err error) {
	typ, err := {{.base.azer_pkg}}.BinDataTypeFromByte(b[0])
	if err != nil {
		return {{.ref_key_type_name}}Zero(), 0,
			errors.ArgWrap("", "type parsing", err)
	}
	if typ != {{.base.azer_pkg}}.BinDataTypeArray {
		return {{.ref_key_type_name}}Zero(), 0,
			errors.Arg("", errors.EntMsg("type", "unsupported"))
	}

	refKey, readLen, err = {{.ref_key_type_name}}FromAZERBinField(b[1:], typ)
	return refKey, readLen + 1, err
}

// AZERBinField is required for conformance
// with {{.base.azcore_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) AZERBinField() ([]byte, {{.base.azer_pkg}}.BinDataType) {
	{{if not .global_scope -}}{{if .hosts -}}
	var typesBytes []byte
	var dataBytes []byte
	var fieldBytes []byte
	var fieldType {{.base.azer_pkg}}.BinDataType

	{{- range $i, $h := .hosts}}

	fieldBytes, fieldType = refKey.{{unexported_field $h}}.AZERBinField()
	typesBytes = append(typesBytes, fieldType.Byte())
	dataBytes = append(dataBytes, fieldBytes...)

	{{- end}}

	fieldBytes, fieldType = refKey.idNum.AZERBinField()
	typesBytes = append(typesBytes, fieldType.Byte())
	dataBytes = append(dataBytes, fieldBytes...)

	var out = []byte{byte(len(typesBytes))}
	out = append(out, typesBytes...)
	out = append(out, dataBytes...)
	return out, {{.base.azer_pkg}}.BinDataTypeArray
	{{- end}}{{- else -}}
	return refKey.idNum.AZERBinField()
	{{- end}}
}

// {{.ref_key_type_name}}FromAZERBinField creates {{.ref_key_type_name}} from
// its azer-bin field form.
func {{.ref_key_type_name}}FromAZERBinField(
	b []byte, typeHint {{.base.azer_pkg}}.BinDataType,
) (refKey {{.ref_key_type_name}}, readLen int, err error) {
	if typeHint != {{.base.azer_pkg}}.BinDataTypeArray {
		return {{.ref_key_type_name}}Zero(), 0,
			errors.Arg("", errors.EntMsg("type", "unsupported"))
	}

	arrayLen := int(b[0])
	if arrayLen != {{unexported_global .ref_key_type_name}}FieldCount {
		return {{.ref_key_type_name}}Zero(), 0,
			errors.Arg("", errors.EntMsg("field count", "mismatch"))
	}

	typeCursor := 1
	dataCursor := typeCursor + arrayLen

	var fieldType {{.base.azer_pkg}}.BinDataType

	{{- if not .global_scope}}{{- range .hosts}}

	fieldType, err = {{$.base.azer_pkg}}.BinDataTypeFromByte(b[typeCursor])
	if err != nil {
		return {{$.ref_key_type_name}}Zero(), 0,
			errors.ArgWrap("", "{{unexported_field .}} ref-key type parsing", err)
	}
	typeCursor++
	{{unexported_field .}}RefKey, readLen, err := {{.}}RefKeyFromAZERBinField(
		b[dataCursor:], fieldType)
	if err != nil {
		return {{$.ref_key_type_name}}Zero(), 0,
			errors.ArgWrap("", "{{unexported_field .}} ref-key data parsing", err)
	}
	dataCursor += readLen

	{{- end}}{{- end}}

	fieldType, err = {{.base.azer_pkg}}.BinDataTypeFromByte(b[typeCursor])
	if err != nil {
		return {{.ref_key_type_name}}Zero(), 0,
			errors.ArgWrap("", "idnum type parsing", err)
	}
	typeCursor++
	idNum, readLen, err := {{.id_num_type_name}}FromAZERBinField(
		b[dataCursor:], fieldType)
	if err != nil {
		return {{.ref_key_type_name}}Zero(), 0,
			errors.ArgWrap("", "idnum data parsing", err)
	}
	dataCursor += readLen

	return {{.ref_key_type_name}}{
		{{if not .global_scope -}}{{- range .hosts -}}
		{{unexported_field .}}: {{arg_name .}}RefKey,
		{{end}}{{end -}}
		idNum: idNum,
	}, dataCursor, nil
}

// UnmarshalAZERBinField is required for conformance
// with {{.base.azcore_pkg}}.BinFieldUnmarshalable.
func (refKey *{{.ref_key_type_name}}) UnmarshalAZERBinField(
	b []byte, typeHint {{.base.azer_pkg}}.BinDataType,
) (readLen int, err error) {
	i, readLen, err := {{.ref_key_type_name}}FromAZERBinField(b, typeHint)
	if err == nil {
		*refKey = i
	}
	return readLen, err
}

const {{unexported_global .ref_key_type_name}}AZERTextPrefix = "{{.ref_key_def.azer_text.prefix}}"

// AZERText is required for conformance
// with {{.base.azcore_pkg}}.RefKey.
func (refKey {{.ref_key_type_name}}) AZERText() string {
	if !refKey.IsValid() {
		return ""
	}

	return {{unexported_global .ref_key_type_name}}AZERTextPrefix +
		{{.base.azer_pkg}}.TextEncode(refKey.AZERBin())
}

// {{.ref_key_type_name}}FromAZERText creates a new instance of
// {{.ref_key_type_name}} from its azer-text form.
func {{.ref_key_type_name}}FromAZERText(s string) ({{.ref_key_type_name}}, error) {
	if s == "" {
		return {{.ref_key_type_name}}Zero(), nil
	}
	if !strings.HasPrefix(s, _{{.ref_key_type_name}}AZERTextPrefix) {
		return {{.ref_key_type_name}}Zero(),
			errors.Arg("", errors.EntMsg("prefix", "mismatch"))
	}
	s = strings.TrimPrefix(s, _{{.ref_key_type_name}}AZERTextPrefix)
	b, err := {{.base.azer_pkg}}.TextDecode(s)
	if err != nil {
		return {{.ref_key_type_name}}Zero(),
			errors.ArgWrap("", "data parsing", err)
	}
	refKey, _, err := {{.ref_key_type_name}}FromAZERBin(b)
	if err != nil {
		return {{.ref_key_type_name}}Zero(),
			errors.ArgWrap("", "data decoding", err)
	}
	return refKey, nil
}

// UnmarshalAZERText is required for conformance
// with {{.base.azer_pkg}}.TextUnmarshalable.
func (refKey *{{.ref_key_type_name}}) UnmarshalAZERText(s string) error {
	r, err := {{.ref_key_type_name}}FromAZERText(s)
	if err == nil {
		*refKey = r
	}
	return err
}

// MarshalText is for compatibility with Go's encoding.TextMarshaler
func (refKey {{.ref_key_type_name}}) MarshalText() ([]byte, error) {
	return []byte(refKey.AZERText()), nil
}

// UnmarshalText is for conformance with Go's encoding.TextUnmarshaler
func (refKey *{{.ref_key_type_name}}) UnmarshalText(b []byte) error {
	r, err := {{.ref_key_type_name}}FromAZERText(string(b))
	if err == nil {
		*refKey = r
	}
	return err
}

// MarshalJSON makes this type JSON-marshalable.
func (refKey {{.ref_key_type_name}}) MarshalJSON() ([]byte, error) {
	// We assume that there's no symbols in azer-text
	return []byte("\"" + refKey.AZERText() + "\""), nil
}

// UnmarshalJSON parses a JSON value.
func (refKey *{{.ref_key_type_name}}) UnmarshalJSON(b []byte) error {
	s := strings.Trim(string(b), "\"")
	if s == "" {
		*refKey = {{.ref_key_type_name}}Zero()
		return nil
	}
	i, err := {{.ref_key_type_name}}FromAZERText(s)
	if err == nil {
		*refKey = i
	}
	return err
}

{{- if not .global_scope}}{{range .hosts}}

// {{.}} returns instance's {{.}} value.
func (refKey {{$.ref_key_type_name}}) {{.}}() {{.}}RefKey {
	return refKey.{{unexported_field .}}
}

// With{{.}} returns a copy
// of {{$.ref_key_type_name}}
// with its {{unexported_field .}} attribute set to the provided value.
func (refKey {{$.ref_key_type_name}}) With{{.}}(
	{{arg_name .}} {{.}}RefKey,
) {{$.ref_key_type_name}} {
	{{- $p := .}}
	return {{$.ref_key_type_name}}{
		{{- range $.hosts}}{{if eq . $p}}
		{{unexported_field .}}: {{arg_name .}},{{else}}
		{{unexported_field .}}: refKey.{{unexported_field .}},{{end}}{{- end}}
		idNum: refKey.idNum,
	}
}

{{- end}}{{end}}

// {{.ref_key_type_name}}Error defines an interface for all
// {{.ref_key_type_name}}-related errors.
type {{.ref_key_type_name}}Error interface {
	error
	{{.ref_key_type_name}}Error()
}
