module: iam
symbols:

  - identifier: User
    # This defines what this entity's role in the system. In a system, a role
    # can have only one concrete. Not to be confused with 'role' in access
    # control.
    abstract: User
    kind: entity
    parameters:
      lifecycle:
        creation:
      id:
        # Options: integer(space), uuid(version), string
        kind: integer
        parameters:
          space: 48
        generator:
          # Other options: ShardedRandomIntegerGenerator
          # The option for generator is defined by the registered generators
          # to the compiler.
          # Root entities can only use random generators.
          name: LocalRandomIntegerIDGenerator
          parameters:
            encodings:
              text:
                prefix: "ix-"
      mixins:
        - kind: Deletion
          parameters:
            event_hooks:
              enabled: true
            api:
      # Declares the creation rules. This defines how and who can create
      # an instance.
      creation:
        allow_inter_process: false
        # The authorization definition for the creation method.
        access:
          # Here, we allow creation from the same service process
          - kind: intraprocess-private
            authorization: none
            allow: always
          - kind: intraprocess-public
            authorization: none
            allow: always
          - kind: interprocess-private (same host, loopback)
            allow: none
          - kind: interprocess-public (through public transport, e.g., internet)
            allow: none
      service:
        enabled: true
        methods:
        api:
          protocols:
            #?RFC: versioning?
            rest:
              enabled: true
            grpc:
              enabled: true

  - identifier: IdentifierPhoneNumber
    kind: adjunct
    parameters:
      hosts:
        - name: User
      kind: value-object
      parameters:
        kind: telephony.PhoneNumber
        unique: true

  - identifier: Application
    documentation: |
      An Application is an ....
    kind: entity
    parameters:
      # TODO: encode application type into the ID. we will then use
      # the same method to encode the type into Terminal ID.
      id:
        kind: integer
        parameters:
          space: 24
      creation:
        allow_inter_process: true
      mixins:
        - kind: Ownership
          parameters:
            owner_arity:
              # overridable means that the configuration could be overriden
              # through, e.g., environment variables or config server.
              # RFC: should we, instead making these value here as value
              # available in config server?
              overridable: true
              value:
                min: 1
                max: 4
      attributes:
        - identifier: AccessKeys
          # A set of AccessKey with uniqueness is defined by the field id
          # by default, we use object's defined key, or we will use the
          # equality trait (value objects are required to provide equality
          # operator)
          kind: set
          parameters:
            kind: AccessKey
            key_fields: [id]
            arity:
              min: 0
              max: 4

  - identifier: ApplicationAccessKey
    kind: adjunct
    parameters:
      prepared_name: true
      hosts:
        - name: Application
      arity:
        min: 0
        max: 4
      kind: entity
      parameters:
        id:
          kind: integer
          parameters:
            space: 24
        attributes:
          - identifier: Secret
            kind: ApplicationAccessKeySecret

  - identifier: Terminal
    documentation: |
      A Terminal is an authorized instance of application. As long the the
      authorization is still valid, a terminal could be used to access the
      service. An authorization of a Terminal will become invalid when it
      is expired or revoked by the user, if the terminal is associated to
      a user, or those who have the permission to revoke the authorization.

      After a Terminal authorization is invalid, the user must re-authorize
      their instance of Application if they wish to continue using their
      instance of Application to access the service. Re-authorization of an
      instance of an Application will generate a new Terminal. A
      de-authorized Terminal is no longer usable.

      A sucessful authorization will generate both a new Terminal and
      an initial Session.
    kind: adjunct
    parameters:
      kind: entity
      # At least one
      hosts:
        - name: Application
      parameters:
        # An adjunct entity with global scope will make it more similar to
        # Entity. It's still an adjunct of other entity but an instance
        # is directly addressable instead of through its entities.
        # A global adjunct entity can only have unordered ordering, i.e.,
        # instance IDs are required to be random.
        scope: global
        ref_key:
          prefix: "T0:"
        id:
          unique: true
        mixins:
          - kind: Deletion
            parameters:
        attributes:
          represented_user:
            kind: ref
            parameters:
              kind: User
          request:
            # TODO: union or interface
            # we need to refer to TerminalRegistrationPhoneNumber and
            # other methods of authentication.
            kind: ref
        creation:
          allow_inter_process: false
          authorization:
            - kind: intraprocess
              allow: always
        service:
          methods:

  - identifier: Session
    documentation: |
      A Session represents authorization for a time span. While Terminal
      usually provide longer authorization period, a Session is used to
      break down that authorization into smaller time spans.

      If a Session is expired or revoked, the previously authorized
      Application instance (Terminal) could request another Session as long the
      Application's authorization is still valid. There's only one instance
      of Session active at a time for a Terminal.

      An access token represents a instance of Session.
    kind: adjunct
    parameters:
      kind: entity
      hosts:
        - name: Terminal
          exclusive: true # only one instance of Session for a Terminal active at a time
      arity:
        min: 0
        max: -1
      parameters:
        # a flag to indicate that a session is scoped within its host entities.
        # An instance of local adjunct entity might have a same id with other
        # instance under different hosts.
        scope: local
        id:
          unique: true 
        service:
          enabled: true
          description: |
            Hello.
        mixins:
          - kind: Deletion
            parameters:
          - kind: Expiration
            parameters:
              duration:
                overridable: true
                value:
                  quantity: 1440
                  unit: hour

  # TODO: concept of something, which is required to create an instance of
  # an entity. One instance of this something can only be used for exactly one
  # process.
  # This something might or might not contain part which will be included in
  # the product entity.
  # Idea for the term: substrate, material, artifact, mold, aid, assist,
  # scaffold, proto.
  # TODO: we could just use prebuilt functionality,
  # e.g., PhoneNumberVerification, but we still need to declare something here
  # which brings the functionality here.
  - identifier: TerminalRegistrationPhoneNumber
    documentation: |
      TerminalRegistrationPhoneNumber is used to track terminal registrations
      which each was requested by requesting a verification of a phone-number
      associated to a user.
    kind: entity
    parameters:
      # The idea is that this entity is built upon a component. We are
      # encapsulating the component as an entity in this domain. A component
      # deals only with the value it contained.
      # TODO: same or similar concept to mixins? an entity can have only one
      # component? is this similar to Go's struct embedding?
      component:
        name: PhoneNumberVerificationWithIntegerCode
        parameters:
          code_length: 6
      substrate:
        product:
          kind: Terminal
      id:
        kind: integer
        parameters:
          space: 48
          encodings:
            text:
              prefix: ""
              alg: decimal
      mixins:
        - kind: Deletion
          parameters:
        - kind: Expiration
          parameters:
            duration:
              overridable: true
              value:
                quantity: 5
                unit: minute
      # Creation is a special service method.
      creation:
        # Master flag. Only if the value is true, each of creation methods
        # could set its own flag.
        #
        # By default, this flag is set to false.
        #
        # If the value is false, we won't allow any creation through
        # other application, including the same kind of application on
        # different process/machine; the creation can only be performed by other
        # part of the same application. It means that the entity was
        # designed as by-product of other entity's method, i.e., non-direct
        # creation.
        #
        # If the value is true, we want to allow the creation to be initiated
        # directly by other applications.
        allow_inter_process: true
        allow_cross_domain: true
        authorization:
          - kind: Application
            allow: on-condition
            condition:
              eq:
                a: type
                b: user-agent
        allowed_isolations:
          - all
        methods:
          create:
            allow_inter_process: true
            input_parameters:
              Self.phone_number:
      attributes:
        - identifier: PhoneNumber
          kind: telephony.PhoneNumber
          final: true
        - identifier: VerificationCode
          kind: PhoneNumberVerificationCode
          final: true
      service:
        # Instance methods
        methods:
          confirm:
            # instance arity?
            mutate: true
            authorization:
              - kind: oso
                parameters:
                  policy: 'allow(ctx: Context, "confirm", _resource: Self) if ctx.is_intraprocess'
            input_parameters:
              Self:
              Self.verification_code:
            output_parameters:
              session: Session
            process: |
              self.confirm_verification(code):{
                error(err) -> return err
                ok(phone_number) -> IdentifierPhoneNumber.service.get_user_or_create(phone_number):{
                  error(err) -> return err
                  ok(uid) -> Terminal.create(self.application, uid):{
                    error(err) -> return err
                    ok(term) -> Session.create(term)
                  }
                }
              }

  - identifier: PhoneNumberVerificationCode
    documentation: |
      PhoneNumberVerificationCode is the type for storing the code
      of a phone-number verification.
    kind: value_object
    parameters:
      kind: alias
      parameters:
        data_type: int16
