module: iam
symbols:

  - identifier: User
    kind: entity
    parameters:
      # This defines what this entity's role in the system. In a system, a role
      # can have only one concrete. Not to be confused with 'role' in access
      # control.
      implements: User
      lifecycle:
        creation:
      id:
        # Options: integer(bits), uuid(version), string (encoded bytes; similar
        # to integer but it doesn't have to be valid integer)
        kind: integer
        parameters:
          # Only significant_bits is required, but here, we also define the
          # value of total_bits.
          #
          # This field is used to ensure that the IDs fit in the stated value;
          # the compiler will return error if the IDs doesn't fit in
          # total_bits.
          #
          # Valid value is any of 16 (analogous to int16_t in C/C++,
          # smallint in SQL), 32 (analogous to int32_t in C/C++,
          # int in SQL) and 64 (analogous to int64_t in C/C++, bigint in SQL).
          #
          # If not provided, total_bits will be determined by picking the
          # option value a step larger than the value provided to
          # significant_bits.
          total_bits: 64
          # Max 63
          significant_bits: 48
          bitfield:
            sub_fields:
              - identifier: Bot
                documentation: |
                  Bot account is ....
                bits:
                  - index: 1
                    set: true
        generator:
          # Other options: ShardedRandomIntegerGenerator
          # The option for generator is defined by the registered generators
          # to the compiler.
          # Root entities can only use random generators.
          name: LocalRandomIntegerIDGenerator
          parameters:
            encodings:
              text:
                prefix: "ix-"
      mixins:
        - kind: Deletion
          parameters:
            event_emission:
              enabled: true
            api:
      # Declares the creation rules. This defines how and who can create
      # an instance.
      creation:
        allow_cross_process_callers: false
        allow_cross_process_event_observers: false
      service:
        enabled: true
        methods:
        api:
          protocols:
            #?RFC: versioning?
            rest:
              enabled: true
            grpc:
              enabled: true

  - identifier: IdentifierPhoneNumber
    kind: adjunct
    parameters:
      hosts:
        - name: User
      kind: value_object
      parameters:
        kind: telephony.PhoneNumber
        unique: true

  - identifier: Application
    documentation: |
      An Application is an ....
    kind: entity
    parameters:
      # TODO: encode application type into the ID. we will then use
      # the same method to encode the type into Terminal ID.
      id:
        kind: integer
        parameters:
          total_bits: 32
          #TODO: reserve range?
          #
          # How this will be laid out:
          #
          # 0b00000000000000000000000000000000
          #   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          #   ||||||||||||||||||||||||||||||||
          #   ||||||++++++++++++++++++++++++++- significants (index 0-25)
          #   ||||++- reserved 
          #   |||+--- depends on index 29 (index 28)
          #   ||+---- Service/UserAgent (index 29)
          #   |+----- IsFirstParty (index 30)
          #   +------ reserved for 32bit integer
          significant_bits: 26
          # Bitfield is used to embed limited information to the IDs. This
          # information will be part of the identity of an instance;
          # information can not be changed without changing the identity of
          # the instance.
          #
          # NOTE: changing the schema of bitfields is naturally more
          # difficult than changing the value of entity attributes or adjuncts.
          # Use bitfield only for optimization of a well-defined, stable
          # practice, and the information is part of the identity of each
          # instance.
          #
          # An example use case for bitfield is to allow resource servers to
          # quickly determine if an access will be allowed or not based on the
          # type of the application embedded into the ID of the application
          # which made the request. By quickly here we mean that this check
          # doesn't required to get this type information from the
          # database. The limitation in this use case is that the type of the
          # application can not be changed without changing the
          # identity of the application.
          #
          # If we have 26bit significants, and we want the identifier to fit
          # in 32bit integers, first, we substract it by 1 (for ensuring it
          # fits in 32bit signed integers), then substract it with the number
          # of significants, in this case 26. So it will be: 32 - 1 - 26 = 5.
          # Five is the maximum size of the bitfield if we have 26bit
          # significants and we want it to fit in 32bit integers.
          bitfield:
            # The size of the bitfield, i.e., the number of bits we reserve for
            # this bitfield. This field is optional as the compiler will
            # infer this value by substracting total_bits with
            # significant_bits.
            size: 5
            #TODO: copied sub_fields
            sub_fields:
              - identifier: FirstParty
                documentation: |
                  FirstParty indicates that the application is a first-party
                  application, i.e., an application that we official support.

                  First-party applications, in contrast to third party
                  applications, are those of official applications, officially
                  supported applications, or internal-use only applications.

                  First-party applications could be in various forms, e.g.,
                  official mobile app, web app, or system dashboard.
                bits:
                  # Index starts from 0. The maximum index is bitfield size - 1.
                  # An index is scoped within the bitfield, i.e., the first
                  # bit of a bitfield is always index 0.
                  - index: 0
                    set: true
              - identifier: Service
                documentation: |
                  Service application is an application which does not
                  represent user. Note that this is different from, e.g.,
                  bot, where it's a specialization of User; a bot is a User.
                bits:
                  - index: 1
                    set: false
                  - index: 2
                    set: true
              - identifier: UserAgent
                documentation: |
                  A user-agent application is an application which represents
                  the user it got authorized by.

                  There are two types of user agent: direct and confidential.
                bits:
                  - index: 1
                    set: true
              - identifier: DirectUserAgent
                documentation: |
                  A direct user-agent application is an application which
                  can be used by users to authenticate themselves to the system.
                  The application will automatically receive authorization upon
                  successful user authentication.
                  
                  A direct user-agent credentials should never be assumed to
                  be secure, i.e., authorized direct user-agent application
                  has no strong identity. Access control checks should be
                  focused on testing the user's claims and less of the
                  application's claims.
                bits:
                  - index: 1
                    set: true
                  - index: 2
                    set: false
              - identifier: ConfidentialUserAgent
                documentation: |
                  A confidential user-agent application is a user-agent
                  application which could receive authorization from a
                  consenting user through 3-legged authorization flow. A
                  confidential user-agent can not be used for performing
                  user authentication.
                bits:
                  - index: 1
                    set: true
                  - index: 2
                    set: true
      creation:
        allow_cross_process_callers: true
      mixins:
        - kind: Ownership
          parameters:
            owner_arity:
              # overridable means that the configuration could be overriden
              # through, e.g., environment variables or config server.
              # RFC: should we, instead making these value here as value
              # available in config server?
              overridable: true
              value:
                min: 1
                max: 4

  - identifier: ApplicationAccessKey
    kind: adjunct
    parameters:
      name_is_prepared: true
      hosts:
        - name: Application
      arity:
        min: 0
        max: 4
      kind: entity
      parameters:
        id:
          kind: integer
          parameters:
            total_bits: 64
            significant_bits: 56
            bitfield:
              # An adjunct can inherit its hosts' bitfields.
              # This is similar to entity ID, but instead of encode own
              # attributes, we encode host's attributes.
              #
              # For this specific case, we want to able to quickly determine
              # some of the Application's attributes based on information
              # embedded in this access key ID without the need
              # to fetch the complete data of the Application.
              inherits:
                - host: 0
                  # The size of the inherited bitfield from this host. This
                  # value must be exactly same as host's. This is required
                  # for ensuring consistency.
                  size: 5
              
        attributes:
          - identifier: Secret
            kind: ApplicationAccessKeySecret

  - identifier: Terminal
    documentation: |
      A Terminal is an authorized instance of application. As long the the
      authorization is still valid, a terminal could be used to access the
      service. An authorization of a Terminal will become invalid when it
      is expired or revoked by the user, if the terminal is associated to
      a user, or those who have the permission to revoke the authorization.

      After a Terminal authorization is invalid, the user must re-authorize
      their instance of Application if they wish to continue using their
      instance of Application to access the service. Re-authorization of an
      instance of an Application will generate a new Terminal. A
      de-authorized Terminal is no longer usable.

      A sucessful authorization will generate both a new Terminal and
      an initial Session.
    kind: adjunct
    parameters:
      kind: entity
      # At least one
      hosts:
        - name: Application
      parameters:
        implements: Terminal
        # An adjunct entity with global scope will make it more similar to
        # Entity. It's still an adjunct of other entity but an instance
        # is directly addressable instead of through its entities.
        # A global adjunct entity can only have unordered ordering, i.e.,
        # instance IDs are required to be random.
        scope: global
        ref_key:
          prefix: "T0:"
        id:
          kind: integer
          parameters:
            total_bits: 64
            significant_bits: 56
            bitfield:
              inherits:
                - host: 0
                  size: 5
        mixins:
          - kind: Deletion
            parameters:
        attributes:
          - identifier: RepresentedUser
            kind: ref
            parameters:
              kind: User
          - identifier: RegistrationIdentifier
            # TODO: union or interface
            # we need to refer to TerminalRegistrationPhoneNumber and
            # other methods of authentication.
            kind: ref
        creation:
          allow_cross_process_callers: false
          authorization:
            - kind: intraprocess
              allow: always
        service:
          methods:

  - identifier: Session
    documentation: |
      A Session represents authorization for a time span. While Terminal
      usually provide longer authorization period, a Session is used to
      break down that authorization into smaller time spans.

      If a Session is expired or revoked, the previously authorized
      Application instance (Terminal) could request another Session as long the
      Application's authorization is still valid. There's only one instance
      of Session active at a time for a Terminal.

      An access token represents a instance of Session.
    kind: adjunct
    parameters:
      name_is_prepared: true
      kind: entity
      hosts:
        - name: Terminal
          exclusive: true # only one instance of Session for a Terminal active at a time
      arity:
        min: 0
        max: -1
      parameters:
        implements: Session
        # a flag to indicate that a session is scoped within its host entities.
        # An instance of local adjunct entity might have a same id with other
        # instance under different hosts.
        scope: local
        id:
          kind: integer
          parameters:
            total_bits: 32
            significant_bits: 24
        service:
          enabled: true
          description: |
            Hello.
        mixins:
          - kind: Deletion
            parameters:
          - kind: Expiration
            parameters:
              duration:
                overridable: true
                value:
                  quantity: 1440
                  unit: hour

  # TODO: concept of something, which is required to create an instance of
  # an entity. One instance of this something can only be used for exactly one
  # process.
  # This something might or might not contain part which will be included in
  # the product entity.
  # Idea for the term: substrate, material, artifact, mold, aid, assist,
  # scaffold, proto.
  # TODO: we could just use prebuilt functionality,
  # e.g., PhoneNumberVerification, but we still need to declare something here
  # which brings the functionality here.
  - identifier: TerminalRegistrationPhoneNumber
    documentation: |
      TerminalRegistrationPhoneNumber is used to track terminal registrations
      which each was requested by requesting a verification of a phone-number
      associated to a user.
    kind: entity
    parameters:
      # The idea is that this entity is built upon a component. We are
      # encapsulating the component as an entity in this domain. A component
      # deals only with the value it contained.
      # TODO: same or similar concept to mixins? an entity can have only one
      # component? is this similar to Go's struct embedding?
      component:
        name: PhoneNumberVerificationWithIntegerCode
        parameters:
          code_length: 6
      substrate:
        product:
          kind: Terminal
      id:
        kind: integer
        parameters:
          total_bits: 64
          significant_bits: 48
          encodings:
            text:
              prefix: ""
              alg: decimal
      mixins:
        - kind: Deletion
          parameters:
        - kind: Expiration
          parameters:
            duration:
              overridable: true
              value:
                quantity: 5
                unit: minute
      # Creation is a special service method.
      creation:
        # Master flag. Only if the value is true, each of creation methods
        # could set its own flag.
        #
        # By default, this flag is set to false.
        #
        # If the value is false, we won't allow any creation through
        # other application, including the same kind of application on
        # different process/machine; the creation can only be performed by other
        # part of the same application. It means that the entity was
        # designed as by-product of other entity's method, i.e., non-direct
        # creation.
        #
        # If the value is true, we want to allow the creation to be initiated
        # directly by other applications.
        allow_cross_process_callers: true
        # A flag to determine if applications from other realms is allowed
        # to make call to this method.
        #
        # An application from other realms is an application which received
        # authorization to integrate with this realm. In contrast to
        # own-realm applications.
        allow_cross_realm_callers: false
        authorization:
          - kind: Application
            allow: on-condition
            condition:
              eq:
                a: type
                b: user-agent
        allowed_isolations:
          - all
        methods:
          create:
            allow_cross_process_callers: true
            input_parameters:
              Self.phone_number:
      attributes:
        - identifier: PhoneNumber
          kind: telephony.PhoneNumber
          final: true
        - identifier: VerificationCode
          kind: PhoneNumberVerificationCode
          final: true
      service:
        # Instance methods
        methods:
          confirm:
            # instance arity?
            mutate: true
            authorization:
              - kind: oso
                parameters:
                  policy: 'allow(ctx: Context, "confirm", _resource: Self) if ctx.is_intraprocess'
            input_parameters:
              Self:
              Self.verification_code:
            output_parameters:
              session: Session
            process: |
              self.confirm_verification(code):{
                error(err) -> return err
                ok(phone_number) -> IdentifierPhoneNumber.service.get_user_or_create(phone_number):{
                  error(err) -> return err
                  ok(uid) -> Terminal.create(self.application, uid):{
                    error(err) -> return err
                    ok(term) -> Session.create(term)
                  }
                }
              }

  - identifier: ApplicationAccessKeySecret
    documentation: |
      ApplicationAccessKeySecret encapsulates application access key secret.
    kind: value_object
    parameters:
      kind: alias
      parameters:
        data_type: string

  - identifier: PhoneNumberVerificationCode
    documentation: |
      PhoneNumberVerificationCode is the type for storing the code
      of a phone-number verification.
    kind: value_object
    parameters:
      kind: alias
      parameters:
        data_type: int16
